### üôÄ Construindo nosso boss.

Ent√£o, no nosso jogo o personagem NFT vai estar apto a atacar um boss.

O grande objetivo do jogo √© atacar o boss e levar o HP dele a 0! Mas, o truque aqui √© que o boss tem muito HP e toda vez que atacaramos ele, ele ir√° atacar de voltar e diminuir o nosso HP. Se a vida do nosso personagem chegar a 0, ent√£o o nosso personagem n√£o vai mais poder atacar o boss e vai estar ‚Äúmorto‚Äú.

Talvez no futuro, outro pessoa poder√° construir uma fun√ß√£o de ‚Äúreviver‚Äú que permite que as NFTs mortas ganhem 100% dos pontos de vida ;). Mas por agora, se nosso personagem morrer, √© game over. E n√≥s podemos descansar sabendo que nosso personagem deu o melhor e se deu pelo time. Isso significa que precisamos que outros players ataquem o boss tamb√©m, n√£o podemos fazer isso sozinhos.

Vamos primeiro s√≥ construir uma estrutura b√°sica de um boss e inicializar os dados, de maneira similar ao que fizemos com nossos personagens. O boss vai basicamente ter um nome, imagem, dano de ataque e HP. O boss **n√£o vai** ser uma NFT. Os dados do boss v√£o apenas viver no contrato inteligente.

N√≥s podemos adicionar o seguinte c√≥digo logo abaixo de onde declaramos `nftHolderAttributes`.

```solidity
struct BigBoss {
  string name;
  string imageURI;
  uint hp;
  uint maxHp;
  uint attackDamage;
}

BigBoss public bigBoss;

```

Bem simples! S√≥ uma estrutura para manter os dados do boss de uma maneira organizada e uma vari√°vel `bigBoss` tamb√©m que vai segurar nosso boss para que podemos referenci√°-los em diferentes fun√ß√µes.

Ent√£o, n√≥s podemos s√≥ inicializar nosso boss direto no nosso contrato como isso:

```solidity
constructor(
  string[] memory characterNames,
  string[] memory characterImageURIs,
  uint[] memory characterHp,
  uint[] memory characterAttackDmg,
  string memory bossName, // Essas novas vari√°veis ser√£o passadas via run.js ou deploy.js
  string memory bossImageURI,
  uint bossHp,
  uint bossAttackDamage
)
  ERC721("Heroes", "HERO")
{
  // Inicializa o boss. Salva na nossa vari√°vel global de estado "bigBoss".
  bigBoss = BigBoss({
    name: bossName,
    imageURI: bossImageURI,
    hp: bossHp,
    maxHp: bossHp,
    attackDamage: bossAttackDamage
  });

  console.log("Done initializing boss %s w/ HP %s, img %s", bigBoss.name, bigBoss.hp, bigBoss.imageURI);

  // Todo o c√≥digo do outro personagem est√° aqui embaixo do mesmo jeito que antes, s√≥ n√£o estamos mostrando para manter as coisas simples!

```

Finalmente, s√≥ mudamos `run.js` e `deploy.js` para passar em par√¢metros para o nosso boss:

```javascript
const gameContract = await gameContractFactory.deploy(
  ["Leo", "Aang", "Pikachu"],
  [
    "https://i.imgur.com/pKd5Sdk.png",
    "https://i.imgur.com/xVu4vFL.png",
    "https://i.imgur.com/u7T87A6.png",
  ],
  [100, 200, 300],
  [100, 50, 25],
  "Elon Musk", // Boss name
  "https://i.imgur.com/AksR0tt.png", // Boss image
  10000, // Boss hp
  50 // Boss attack damage
);
```

Parece um pouco feio, mas, √© isso!

N√≥s agora temos um boss cujos dados vivem no nosso contrato. O boss que escolhi √© `Elon Musk`. Isso significa que nossos jogadores precisam andar juntos para **destruir** Elon Musk. Por qu√™ estamos destruindo Elon? Nem ideia. Eu s√≥ pensei que seria engra√ßado se tiv√©ssemos personagens como Aang e o Pikachu atacando o Elon XD.

**Por favor escolha seu pr√≥prio boss - talvez seja o Darth Vader? Talvez o seu tio? Talvez seu gato?** Qualquer coisa que voc√™ trocar, tenha certeza que √© o seu pr√≥prio, n√£o me copie :).

Seria bem divertido se o boss fosse seu cachorro, e ao inv√©s de tentar destru√≠-lo voc√™ tentasse conseguir que ele o amasse mais. E, quanto mais pessoas fizessem carinho nele na cabe√ßa, mais ele amaria o player. Voc√™ poderia ter at√© um quadro de l√≠deres de pssoas que fizeram mais carinho nele.

De qualquer jeito, seja criativo. Esse √© o seu projeto :).

### üëæ Recuperando os atributos das NFTs do jogador.

N√≥s vamos criar uma fun√ß√£o `attackBoss`. Aqui est√° um in√≠cio dela:

```solidity
function attackBoss() public {
 // Pega o estado da NFT do jogador
 // Tenha certeza que o player tenha mais que 0 de HP
 // Tenha certeza de que o boss tenha mais que 0 de HP
 // Permita que o player ataque o boss
 // Permita que o boss ataque o player
}
```

Vamos come√ßar!

A primeira coisa que precisamos fazer √© **recuperar o estado da NFT do personagem do jogador.** Isso vai segurar tudo, como o HP, dano de ataque dos jogadores e etc. Esses dados s√£o segurados no `nftHolderAttributes`, que exige o `tokenId` da NFT. Podemos pegar o `tokenId` a partir de `nftHolders`! Cheque isso :

```solidity
function attackBoss() public {
  // Pega o estado da NFT do jogador
  uint256 nftTokenIdOfPlayer = nftHolders[msg.sender];
  CharacterAttributes storage player = nftHolderAttributes[nftTokenIdOfPlayer];
  console.log("\nPlayer w/ character %s about to attack. Has %s HP and %s AD", player.name, player.hp, player.attackDamage);
  console.log("Boss %s has %s HP and %s AD", bigBoss.name, bigBoss.hp, bigBoss.attackDamage);
}
```

Primeiro, eu pego o `tokenId` da NFT que o player possui usando `nftHolders[msg.sender]`. Ent√£o por exemplo, se eu tivesse mintado a terceira NFT na cole√ß√£o, `nftHolders[msg.sender]` seria igual a `3`!

Eu ent√£o pego os atributos do jogador usando `nftHolderAttributes[nftTokenIdOfPlayer]`. Eu uso a palavra chave `storage` aqui tamb√©m que vai ser mais importante depois. Basicamente, quando fazemos `storage` e depois `player.hp = 0` que iria mudar o valor da vida **na NFT** para `0`.

Em contraste, se f√¥ssemos usar `memory` ao inv√©s de `storage`, iria criar uma c√≥pia local da vari√°vel dentro do escopo da fun√ß√£o. Isso significa que se fiz√©ssemos `player.hp = 0` seria desse jeito apenas na fun√ß√£o e n√£o mudaria o valor global da vari√°vel.

Em `run.js` voc√™ pode testar isso adicionando isso em qualquer lugar embaixo de `gameContract.deployed();`:

```javascript
let txn;
txn = await gameContract.mintCharacterNFT(2);
await txn.wait();

txn = await gameContract.attackBoss();
await txn.wait();
```

Aqui primeiro mintamos um personagem com index `2` que √© o terceiro personagem na nossa array! Para mim, meu terceiro personagem √© o Pikachu. Tem algo bem engra√ßado sobre ter o Pikachu atacando o Elon Musk no jogo.

Esse √© o primeiro personagem NFT que mintamos, ent√£o ele ter√° automaticamente um id de `1`. Por qu√™? Porque `_tokenIds` come√ßa no 0, mas ent√£o incrementamos ele para `1` no `constructor`. Ent√£o, nossa primeira NFT ter√° um ID de `1`, **n√£o** `0`.

Ent√£o, fazemos `attackBoss()`.

Quando rodo isso, isso √© o que consigo:

```plaintext
Done initializing boss Elon Musk w/ HP 10000, img https://i.imgur.com/AksR0tt.png
Done initializing Leo w/ HP 100, img https://i.imgur.com/pKd5Sdk.png
Done initializing Aang w/ HP 200, img https://i.imgur.com/xVu4vFL.png
Done initializing Pikachu w/ HP 300, img https://i.imgur.com/u7T87A6.png
Contract deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Minted NFT w/ tokenId 0 and characterId 2

Player w/ character Pikachu about to attack. Has 300 HP and 25 AD
Boss Elon Musk has 10000 HP and 50 AD
```

Parece bom! `Pikachu` est√° indo atacar nosso boss `Elon Musk`. Tudo funcionou perfeitamente e estamos recuperando o estado das NFTs :).

### üîç Conferir algumas coisas antes de atacar.

Depois, n√≥s s√≥ precisamos checar que o **personagem tenha HP**, se o personagem est√° morto ele n√£o pode atacar! N√≥s vamos precisar ter certeza que o **boss tenha HP**. N√£o d√° para atacar o boss se ele estiver destru√≠do.

Algumas coisas para notar aqui -

- Voc√™ tamb√©m vai notar a palavra chave especial `require` aqui. Sinta-se livre para ler mais [aqui](https://ethereum.stackexchange.com/questions/60585/what-difference-between-if-and-require-in-solidity).

- Se estiver usando VSCode, voc√™ pode ter um aviso dizendo "O estado de mutabilidade da fun√ß√£o pode ser restringido para view". N√£o se estresse! Isso tudo ser√° consertado depois assim que adicionarmos mais coisas aqui :).

```solidity
function attackBoss() public {
  // Pega o estado da NFT do player.
  uint256 nftTokenIdOfPlayer = nftHolders[msg.sender];
  CharacterAttributes storage player = nftHolderAttributes[nftTokenIdOfPlayer];

  console.log("\nPlayer w/ character %s about to attack. Has %s HP and %s AD", player.name, player.hp, player.attackDamage);
  console.log("Boss %s has %s HP and %s AD", bigBoss.name, bigBoss.hp, bigBoss.attackDamage);

  // Tenha certeza que o hp do player √© maior que 0.
  require (
    player.hp > 0,
    "Error: character must have HP to attack boss."
  );

  // Tenha certeza que o HP do boss seja maior que 0.
  require (
    bigBoss.hp > 0,
    "Error: boss must have HP to attack boss."
  );
}
```

### üî´ Ataque o boss!!

Atacar, na verdade **n√£o √©** super f√°cil.

Basicamente, estamos trabalhando com `uint` agora. Isso √© um "[unsigned integer](https://solidity-by-example.org/primitives/)" significando que n√£o pode ser negativo! Isso √© meio estranho. Digamos que o boss tenha 10 HP sobrando e nosso personagem tenha 50 de dano de ataque. Isso significa que precisaremos fazer `10 HP - 50 dano de ataque` para calcular o HP novo do boss, que seria `-40`. Mas, estamos trabalhando com `uint` ent√£o n√£o podemos lidar com n√∫meros negativos!

**Ter√≠amos um erro de overflow ou underflow.**

N√≥s **poder√≠amos** usar `int` que permitiria armazenar n√∫meros negativos. Mas, isso fica bagun√ßado porque a maioria das libraries como OpenZeppelin ou Hardhat n√£o tem um suporte decente para `int` em suas fun√ß√µes de library. Por exemplo, n√≥s umas `Strings.toString` que s√≥ funciona com `uint`. `console.log` tamb√©m n√£o funciona com `int` facilmente.

Ent√£o, vale a pena ficar com `uint` s√≥ pela facilidade por agora.

Basicamente, a maneira de passar por isso √© simplesmente checar se vamos ter um n√∫mero negativo. Se for, setar o HP do chefe para 0 manualmente ao inv√©s de deix√°-lo se tornar negativo.

Vamos come√ßar mergulhando no c√≥digo que j√° escrevemos aqui para que fa√ßa mais sentido!

```solidity
function attackBoss() public {
  // Pega o estado da NFT do jogador.
  uint256 nftTokenIdOfPlayer = nftHolders[msg.sender];
  CharacterAttributes storage player = nftHolderAttributes[nftTokenIdOfPlayer];

  console.log("\nPlayer w/ character %s about to attack. Has %s HP and %s AD", player.name, player.hp, player.attackDamage);
  console.log("Boss %s has %s HP and %s AD", bigBoss.name, bigBoss.hp, bigBoss.attackDamage);

  // Checa se o hp do player √© maior que 0.
  require (
    player.hp > 0,
    "Error: character must have HP to attack boss."
  );

  // Checa que o hp do boss √© maior que 0.
  require (
    bigBoss.hp > 0,
    "Error: boss must have HP to attack boss."
  );

  // Permite que o jogador ataque o boss.
  if (bigBoss.hp < player.attackDamage) {
    bigBoss.hp = 0;
  } else {
    bigBoss.hp = bigBoss.hp - player.attackDamage;
  }
}
```

`bigBoss.hp < player.attackDamage` s√≥ est√° checando se o boss vai ter seu HP reduzido para menos do que 0 no dano de ataque dos jogadores. Por exemplo, se `bigBoss.hp` fosse 10 e `player.attackDamage` fosse 30, ent√£o sabemos que o boss teria seu HP reduzido para menos que 0, o que causaria um erro! Ent√£o, vamos checar esse caso e configurar o hp do boss para 0 manualmente. Se n√£o for para menos que 0, n√≥s s√≥ fazemos `bigBoss.hp = bigBoss.hp - player.attackDamage` o que iria reduzir o HP do boss baseado em quanto dano o jogador d√°!

### üî™ Adicionando a l√≥gica para o boss atacar o jogador.

N√≥s tamb√©m precisamos ter certeza que o HP do jogador n√£o se torne negativo tamb√©m, porque o HP dos jogadores √© um `uint` tamb√©m. Ent√£o fazemos:

```solidity
function attackBoss() public {
  // Pega o estado da NFT do jogador.
  uint256 nftTokenIdOfPlayer = nftHolders[msg.sender];
  CharacterAttributes storage player = nftHolderAttributes[nftTokenIdOfPlayer];

  console.log("\nPlayer w/ character %s about to attack. Has %s HP and %s AD", player.name, player.hp, player.attackDamage);
  console.log("Boss %s has %s HP and %s AD", bigBoss.name, bigBoss.hp, bigBoss.attackDamage);

  // Checa se o hp do player √© maior que 0.
  require (
    player.hp > 0,
    "Error: character must have HP to attack boss."
  );

  // Checa que o hp do boss √© maior que 0.
  require (
    bigBoss.hp > 0,
    "Error: boss must have HP to attack boss."
  );

  // Permite que o jogador ataque o boss.
  if (bigBoss.hp < player.attackDamage) {
    bigBoss.hp = 0;
  } else {
    bigBoss.hp = bigBoss.hp - player.attackDamage;
  }

// Permite que o boss ataque o jogador.
  if (player.hp < bigBoss.attackDamage) {
    player.hp = 0;
  } else {
    player.hp = player.hp - bigBoss.attackDamage;
  }

  console.log("Player attacked boss. New boss hp: %s", bigBoss.hp);
  console.log("Boss attacked player. New player hp: %s\n", player.hp);
}
```

√â isso! Se `player.hp < bigBoss.attackDamage` ent√£o isso significa que o boss causaria um dano que levaria a vida do jogador para menos que 0, e isso causaria um erro. Ent√£o, checamos isso e manualmente configuramos `player.hp = 0`. Sen√£o, apenas configuramos o novo valor de HP dos jogadores usando `player.hp = player.hp - bigBoss.attackDamage;`

Antes de rodar isso, tenha certeza que `run.js` chame `attackBoss` duas vezes :).

```javascript
let txn;
txn = await gameContract.mintCharacterNFT(2);
await txn.wait();

txn = await gameContract.attackBoss();
await txn.wait();

txn = await gameContract.attackBoss();
await txn.wait();
```

Agora quando rodo `run.js` aqui est√° o que eu consigo:

```plaintext
Done initializing boss Elon Musk w/ HP 10000, img https://i.imgur.com/AksR0tt.png
Done initializing Leo w/ HP 100, img https://i.imgur.com/pKd5Sdk.png
Done initializing Aang w/ HP 200, img https://i.imgur.com/xVu4vFL.png
Done initializing Pikachu w/ HP 300, img https://i.imgur.com/u7T87A6.png
Contract deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Minted NFT w/ tokenId 0 and characterId 2

Player w/ character Pikachu about to attack. Has 300 HP and 25 AD
Boss Elon Musk has 10000 HP and 50 AD
Player attacked boss. New boss hp: 9975
Boss attacked player. New player hp: 250

Player w/ character Pikachu about to attack. Has 250 HP and 25 AD
Boss Elon Musk has 9975 HP and 50 AD
Player attacked boss. New boss hp: 9950
Boss attacked player. New player hp: 200
```

**Est√° tudo funcionando?** Vamos ver. Parece que o `Pikachu` atacou o `Elon Musk` com `25 AD` e a sa√∫de do Elon caiu de `10000` para `9975` o que est√° certo! Ent√£o o Elon ataca o Pikachu com `50` de dano de ataque e a sa√∫de do Pikachu cai de `300` para `250`. Parece que tudo est√° funcionando bem :).

Voc√™ pode ver que quando atacamos uma segunda vez, os valores atualizados de HP s√£o usados tanto para o personagem quanto para o boss :).

Sinta-se livre para testar essa fun√ß√£o tentando com um boss com `1 de HP` ou um player com `1 de HP` brincando com os valores passados no constructor em `run.js`.

Por exemplo, se eu dou ao jogador `1 HP`, aqui est√° o resultado:

```plaintext
Done initializing boss Elon Musk w/ HP 10000, img https://i.imgur.com/AksR0tt.png
Done initializing Leo w/ HP 100, img https://i.imgur.com/pKd5Sdk.png
Done initializing Aang w/ HP 200, img https://i.imgur.com/xVu4vFL.png
Done initializing Pikachu w/ HP 300, img https://i.imgur.com/u7T87A6.png
Contract deployed to: 0x5FbDB2315678afecb367f032d93F642f64180aa3
Minted NFT w/ tokenId 0 and characterId 2

Player w/ character Pikachu about to attack. Has 1 HP and 25 AD
Boss Elon Musk has 10000 HP and 50 AD
Player attacked boss. New boss hp: 9975
Boss attacked player. New player hp: 0

Player w/ character Pikachu about to attack. Has 0 HP and 25 AD
Boss Elon Musk has 9975 HP and 50 AD
Error: VM Exception while processing transaction: reverted with reason string 'Error: character must have HP to attack boss.'
    at MyEpicGame.attackBoss (contracts/MyEpicGame.sol:88)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at runNextTicks (node:internal/process/task_queues:65:3)
    at listOnTimeout (node:internal/timers:526:9)
    at processTimers (node:internal/timers:500:7)
    at HardhatNode._mineBlockWithPendingTxs (/Users/flynn/Developer/epic-game/node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:1582:23)
    at HardhatNode.mineBlock (/Users/flynn/Developer/epic-game/node_modules/hardhat/src/internal/hardhat-network/provider/node.ts:435:16)
    at EthModule._sendTransactionAndReturnHash (/Users/flynn/Developer/epic-game/node_modules/hardhat/src/internal/hardhat-network/provider/modules/eth.ts:1494:18)
```

Ent√£o, voc√™ pode ver que o primeiro ataque aconteceu de maneira correta, `Boss attacked player. New player hp: 0`. Incr√≠vel! Nossa fun√ß√£o funcionou perfeitamente. O hp do nosso personagem ia ser negativo, mas foi configurado para `0`! Yay!

Mas, na seugnda vez que atacamos, conseguimos um erro com: `Error: character must have HP to attack boss`. O que est√° correto!!! Isso √© basciamente como devolver um erro na nsosa API quando algo d√° errado.

Legal - nossa fun√ß√£o `attack boss` est√° basicamente feita. Vamos adicionar mais alguma m√°gica depois mas por agora estamos bem. N√≥s oficialmente temos nossa l√≥gica de jogo **on-chain** :).