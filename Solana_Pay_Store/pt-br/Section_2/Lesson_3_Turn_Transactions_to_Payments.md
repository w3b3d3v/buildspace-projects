Nossas transa√ß√µes est√£o sendo enviadas, mas n√£o estamos fazendo nada para verificar se elas est√£o realmente sendo confirmadas. Talvez elas tenham falhado por algum motivo? Aqui est√° o que voc√™ precisa fazer para confirmar!

### ü§î Confirme transa√ß√µes

Volte para o seu componente `Buy.js` e atualize-o para:

```jsx
import React, { useState, useEffect, useMemo } from "react";
import { Keypair, Transaction } from "@solana/web3.js";
import { findReference, FindReferenceError } from "@solana/pay";
import { useConnection, useWallet } from "@solana/wallet-adapter-react";
import { InfinitySpin } from "react-loader-spinner";
import IPFSDownload from "./IpfsDownload";

const STATUS = {
  Initial: "Initial",
  Submitted: "Submitted",
  Paid: "Paid",
};

export default function Buy({ itemID }) {
  const { connection } = useConnection();
  const { publicKey, sendTransaction } = useWallet();
  const orderID = useMemo(() => Keypair.generate().publicKey, []); // Chave p√∫blica usada para identificar o pedido

  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState(STATUS.Initial); // Acompanhamento do status da transa√ß√£o

  const order = useMemo(
    () => ({
      buyer: publicKey.toString(),
      orderID: orderID.toString(),
      itemID: itemID,
    }),
    [publicKey, orderID, itemID]
  );

  const processTransaction = async () => {
    setLoading(true);
    const txResponse = await fetch("../api/createTransaction", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(order),
    });
    const txData = await txResponse.json();

    const tx = Transaction.from(Buffer.from(txData.transaction, "base64"));
    console.log("Os dados da Tx s√£o", tx);

    try {
      const txHash = await sendTransaction(tx, connection);
      console.log(`Transa√ß√£o enviada: https://solscan.io/tx/${txHash}?cluster=devnet`);
      setStatus(STATUS.Submitted);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };
 
  useEffect(() => {
    // Verifique se a transa√ß√£o foi confirmada
    if (status === STATUS.Submitted) {
      setLoading(true);
      const interval = setInterval(async () => {
        try {
          const result = await findReference(connection, orderID);
          console.log("Encontrando refer√™ncia da tx", result.confirmationStatus);
          if (result.confirmationStatus === "confirmed" || result.confirmationStatus === "finalized") {
            clearInterval(interval);
            setStatus(STATUS.Paid);
            setLoading(false);
            alert("Obrigado por sua compra!");
          }
        } catch (e) {
          if (e instanceof FindReferenceError) {
            return null;
          }
          console.error("Erro desconhecido", e);
        } finally {
          setLoading(false);
        }
      }, 1000);
      return () => {
        clearInterval(interval);
      };
    }
  }, [status]);

  if (!publicKey) {
    return (
      <div>
        <p>Voc√™ precisa conectar sua carteira para fazer transa√ß√µes</p>
      </div>
    );
  }

  if (loading) {
    return <InfinitySpin color="gray" />;
  }

  return (
    <div>
      { status === STATUS.Paid ? (
        <IPFSDownload filename="emojis.zip" hash="QmWWH69mTL66r3H8P4wUn24t1L5pvdTJGUTKBqT11KCHS5" cta="Download emojis"/>
      ) : (
        <button disabled={loading} className="buy-button" onClick={processTransaction}>
          Compre Agora ü†ö
        </button>
      )}
    </div>
  );
}
```

Aqui est√° o novo bloco que adicionamos:

```jsx
  useEffect(() => {
    // Verifique se a transa√ß√£o foi confirmada
    if (status === STATUS.Submitted) {
      setLoading(true);
      const interval = setInterval(async () => {
        try {
          // Procure nosso orderID na blockchain
          const result = await findReference(connection, orderID);
          console.log("Encontrando refer√™ncia da tx", result.confirmationStatus);
          
          // Se a transa√ß√£o for confirmada ou finalizada, o pagamento foi efetuado com sucesso!
          if (result.confirmationStatus === "confirmed" || result.confirmationStatus === "finalized") {
            clearInterval(interval);
            setStatus(STATUS.Paid);
            setLoading(false);
            alert("Obrigado por sua compra!");
          }
        } catch (e) {
          if (e instanceof FindReferenceError) {
            return null;
          }
          console.error("Erro desconhecido", e);
        } finally {
          setLoading(false);
        }
      }, 1000);
      return () => {
        clearInterval(interval);
      };
    }
  }, [status]);
```
Esta √© a magia da Solana Pay. Quando criamos nosso objeto de transa√ß√£o, adicionamos um ID de pedido como campo de refer√™ncia. A Solana Pay nos permite pesquisar transa√ß√µes por refer√™ncia. Isso significa que podemos verificar instantaneamente se um pagamento foi feito sem qualquer busca profunda.

```jsx
const result = await findReference(connection, orderID);
```

A fun√ß√£o [`findReference`](https://docs.solanapay.com/api/core/function/findReference) procura a assinatura de transa√ß√£o mais antiga referenciando nosso orderID. Se encontrarmos um, verificamos se o status da transa√ß√£o foi confirmado ou finalizado.

```jsx
  if (e instanceof FindReferenceError) {
    return null;
  }
```

Esta fun√ß√£o dar√° erro se a transa√ß√£o n√£o for encontrada e isso pode acontecer logo ap√≥s a transa√ß√£o ser enviada. Ent√£o verificamos se o erro foi da classe [`FindReferenceError`](https://docs.solanapay.com/api/core/class/FindReferenceError) e o ignoramos.

Se tudo correr conforme o planejado, nosso c√≥digo come√ßar√° a procurar a transa√ß√£o assim que o usu√°rio clicar em "Aprovar". A primeira pesquisa provavelmente falhar√° porque as transa√ß√µes demoram cerca de 0,5s. √â por isso que estamos usando `setInterval` >:D. Na segunda vez que verificar, encontrar√° a transa√ß√£o e a confirmar√°, atualizando nosso aplicativo para indicar o pagamento.

ISSO √â ALGO GRANDIOSO! A raz√£o pela qual usamos blockchains √© para que n√£o tenhamos que nos preocupar com transa√ß√µes inv√°lidas. Quando a Solana Pay informa que uma transa√ß√£o foi confirmada, voc√™ **sabe** que uma transa√ß√£o foi confirmada e que o dinheiro est√° em sua carteira. Sem estornos :P

### üß† Adicionar ao livro de pedidos

H√° um pequeno problema agora. Se voc√™ fizer um pagamento e atualizar sua p√°gina, o bot√£o de download desaparecer√°!

Isso ocorre porque n√£o estamos armazenando pedidos em lugar nenhum. Vamos consertar isso.

Primeiro, precisaremos criar um arquivo `orders.json` no diret√≥rio `pages/api`. Deixe-o vazio por enquanto, o meu est√° assim:

```json
[

]
```

Em seguida, criaremos um ponto de extremidade de API para gravar e ler a partir dele. Vamos usar o `orders.json` como outro banco de dados rsrs.

Aqui est√° meu arquivo de ponto de extremidade da API `orders.js` (dentro do diret√≥rio `pages/api`):

```jsx
// Este ponto de extremidade da API permitir√° que os usu√°rios usem POST e publiquem dados para adicionar registros e GET para recuperar registros
import orders from "./orders.json";
import { writeFile } from "fs/promises";

function get(req, res) {
  const { buyer } = req.query;

  // Verifique se este endere√ßo tem algum pedido
  const buyerOrders = orders.filter((order) => order.buyer === buyer);
  if (buyerOrders.length === 0) {
    // 204 = processou a solicita√ß√£o com sucesso, n√£o retornando nenhum conte√∫do
    res.status(204).send();
  } else {
    res.status(200).json(buyerOrders);
  }
}

async function post(req, res) {
  console.log("Pedido de adi√ß√£o de pedido recebido", req.body);
  // Adicionar novo pedido a orders.json
  try {
    const newOrder = req.body;

    // Se este endere√ßo n√£o tiver comprado este item, adicione pedido a orders.json
    if (!orders.find((order) => order.buyer === newOrder.buyer.toString() && order.itemID === newOrder.itemID)) {
      orders.push(newOrder);
      await writeFile("./pages/api/orders.json", JSON.stringify(orders, null, 2));
      res.status(200).json(orders);
    } else {
      res.status(400).send("O pedido j√° existe");
    }
  } catch (err) {
    res.status(400).send(err);
  }
}

export default async function handler(req, res) {
  switch (req.method) {
    case "GET":
      get(req, res);
      break;
    case "POST":
      await post(req, res);
      break;
    default:
      res.status(405).send(`M√©todo ${req.method} n√£o permitido`);
  }
}
```

Isso tudo √© apenas JavaScript simples, sinta-se √† vontade para revisar :)

Na verdade, tudo o que √© feito √© a leitura dos dados e a grava√ß√£o no arquivo orders.json.

Em seguida, precisaremos interagir com essa API. *Poder√≠amos* fazer isso sempre que precisarmos dos arquivos individuais, mas isso √© uma pr√°tica ruim. Em vez disso, criaremos um arquivo dedicado para ele.

Crie uma pasta "lib" no diret√≥rio raiz do seu projeto (mesmo n√≠vel dos componentes) e adicione um arquivo `api.js` nela.

Veja como ficar√°:

```jsx
export const addOrder = async (order) => {
  console.log("adicionando pedido", order, "para o banco de dados");
  await fetch("../api/orders", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(order),
  });
};
```

Muito bem! Agora, para usar isso, tudo o que precisamos fazer √© importar a fun√ß√£o `addOrder` e cham√°-la em `Buy.js` logo ap√≥s a confirma√ß√£o da transa√ß√£o. Veja como est√° meu √∫ltimo `Buy.js`:

```jsx
import React, { useState, useEffect, useMemo } from 'react';
import { Keypair, Transaction } from '@solana/web3.js';
import { findReference, FindReferenceError } from '@solana/pay';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { InfinitySpin } from 'react-loader-spinner';
import IPFSDownload from './IpfsDownload';
import { addOrder } from '../lib/api';

const STATUS = {
  Initial: 'Initial',
  Submitted: 'Submitted',
  Paid: 'Paid',
};

export default function Buy({ itemID }) {
  const { connection } = useConnection();
  const { publicKey, sendTransaction } = useWallet();
  const orderID = useMemo(() => Keypair.generate().publicKey, []); // Chave p√∫blica usada para identificar o pedido

  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState(STATUS.Initial); // Acompanhamento do status da transa√ß√£o

  const order = useMemo(
    () => ({
      buyer: publicKey.toString(),
      orderID: orderID.toString(),
      itemID: itemID,
    }),
    [publicKey, orderID, itemID]
  );

  const processTransaction = async () => {
    setLoading(true);
    const txResponse = await fetch('../api/createTransaction', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(order),
    });
    const txData = await txResponse.json();

    const tx = Transaction.from(Buffer.from(txData.transaction, 'base64'));
    console.log('Os dados da Tx s√£o', tx);

    try {
      const txHash = await sendTransaction(tx, connection);
      console.log(
        `Transa√ß√£o enviada: https://solscan.io/tx/${txHash}?cluster=devnet`
      );
      setStatus(STATUS.Submitted);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Verifique se a transa√ß√£o foi confirmada
    if (status === STATUS.Submitted) {
      setLoading(true);
      const interval = setInterval(async () => {
        try {
          const result = await findReference(connection, orderID);
          console.log('Encontrando refer√™ncia da tx', result.confirmationStatus);
          if (
            result.confirmationStatus === 'confirmed' ||
            result.confirmationStatus === 'finalized'
          ) {
            clearInterval(interval);
            setStatus(STATUS.Paid);
            setLoading(false);
            addOrder(order);
            alert('Obrigado por sua compra!');
          }
        } catch (e) {
          if (e instanceof FindReferenceError) {
            return null;
          }
          console.error('Erro desconhecido', e);
        } finally {
          setLoading(false);
        }
      }, 1000);
      return () => {
        clearInterval(interval);
      };
    }
  }, [status]);

  if (!publicKey) {
    return (
      <div>
        <p>Voc√™ precisa conectar sua carteira para fazer transa√ß√µes</p>
      </div>
    );
  }

  if (loading) {
    return <InfinitySpin color="gray" />;
  }

  return (
    <div>
      {status === STATUS.Paid ? (
        <IPFSDownload
          filename="emojis.zip"
          hash="QmWWH69mTL66r3H8P4wUn24t1L5pvdTJGUTKBqT11KCHS5"
          cta="Download emojis"
        />
      ) : (
        <button
          disabled={loading}
          className="buy-button"
          onClick={processTransaction}
        >
          Compre Agora ü†ö
        </button>
      )}
    </div>
  );
}
```

### üö® Relat√≥rio de progresso

Voc√™ agora tem um aplicativo Full Stack! Frontend, backend, servidor, blockchain, woohoo!

Poste uma captura de tela do seu editor em #progress mostrando a instru√ß√£o do console "Adicionando pedido".
