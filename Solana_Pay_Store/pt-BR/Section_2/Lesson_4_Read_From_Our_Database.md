## üíæ Lendo dados do banco de dados

Agora que estamos adicionando itens ao nosso "banco de dados" de pedidos, seria bom se o us√°ssemos üòÇ.

### üëÄ Verificar no carregamento se eles j√° compraram anteriormente

O fluxo para fazer isso vai ser muito semelhante ao `addOrder`. Primeiro, volte para `lib/api.js` e acrescente este manipulador:

```jsx
// Retorna verdadeiro se uma determinada chave p√∫blica tiver adquirido um item anteriormente
export const hasPurchased = async (publicKey, itemID) => {
  // Enviar um pedido GET com a chave p√∫blica como par√¢metro
  const response = await fetch(`../api/orders?buyer=${publicKey.toString()}`);
  // Se o c√≥digo-resposta √© 200
  if (response.status === 200) {
    const json = await response.json();
    console.log("Os pedidos atuais de carteira s√£o:", json);
    // Se os pedidos n√£o estiverem vazios
    if (json.length > 0) {
      // Verifique se h√° algum registro com este comprador e identifica√ß√£o do item
      const order = json.find((order) => order.buyer === publicKey.toString() && order.itemID === itemID);
      if (order) {
        return true;
      }
    }
  }
  return false;
};
```


Isto s√≥ vai interagir com nosso ponto de extremidade /orders e verificar se um determinado endere√ßo comprou um item espec√≠fico. Para implement√°-lo, precisaremos fazer 3 coisas em `Buy.js`:

1. Atualizar as importa√ß√µes para incluir hasPurchased
2. Executar a verifica√ß√£o hasPurchased no carregamento da p√°gina em um useEffect 

Eis como vai ficar:

```jsx
import React, { useState, useEffect, useMemo } from 'react';
import { Keypair, Transaction } from '@solana/web3.js';
import { findReference, FindReferenceError } from '@solana/pay';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { InfinitySpin } from 'react-loader-spinner';
import IPFSDownload from './IpfsDownload';
import { addOrder, hasPurchased } from '../lib/api';

const STATUS = {
  Initial: 'Initial',
  Submitted: 'Submitted',
  Paid: 'Paid',
};

export default function Buy({ itemID }) {
  const { connection } = useConnection();
  const { publicKey, sendTransaction } = useWallet();
  const orderID = useMemo(() => Keypair.generate().publicKey, []); // Chave p√∫blica utilizada para identificar o pedido

  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState(STATUS.Initial); // Status do rastreamento da transa√ß√£o

  const order = useMemo(
    () => ({
      buyer: publicKey.toString(),
      orderID: orderID.toString(),
      itemID: itemID,
    }),
    [publicKey, orderID, itemID]
  );

  const processTransaction = async () => {
    setLoading(true);
    const txResponse = await fetch('../api/createTransaction', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(order),
    });
    const txData = await txResponse.json();

    const tx = Transaction.from(Buffer.from(txData.transaction, 'base64'));
    console.log('Os dados da transa√ß√£o s√£o', tx);

    try {
      const txHash = await sendTransaction(tx, connection);
      console.log(
        `Transa√ß√£o enviada: https://solscan.io/tx/${txHash}?cluster=devnet`
      );
      setStatus(STATUS.Submitted);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Verificar se este endere√ßo j√° comprou este item
    // Se for o caso, buscar o item e ajustar o pagamento para verdadeiro
    // Fun√ß√£o Async para evitar o bloqueio da IU
    async function checkPurchased() {
      const purchased = await hasPurchased(publicKey, itemID);
      if (purchased) {
        setStatus(STATUS.Paid);
        console.log("O endere√ßo j√° adquiriu esse item!");
      }
    }
    checkPurchased();
  }, [publicKey, itemID]);

  useEffect(() => {
    if (status === STATUS.Submitted) {
      setLoading(true);
      const interval = setInterval(async () => {
        try {
          const result = await findReference(connection, orderID);
          console.log('Localizar a refer√™ncia da transa√ß√£o', result.confirmationStatus);
          if (
            result.confirmationStatus === 'confirmed' ||
            result.confirmationStatus === 'finalized'
          ) {
            clearInterval(interval);
            setStatus(STATUS.Paid);
            setLoading(false);
            addOrder(order);
            alert('Obrigado por sua compra!');
          }
        } catch (e) {
          if (e instanceof FindReferenceError) {
            return null;
          }
          console.error('Erro desconhecido', e);
        } finally {
          setLoading(false);
        }
      }, 1000);
      return () => {
        clearInterval(interval);
      };
    }
  }, [status]);

  if (!publicKey) {
    return (
      <div>
        <p>√â necess√°rio conectar sua carteira para realizar a transa√ß√£o</p>
      </div>
    );
  }

  if (loading) {
    return <InfinitySpin color="gray" />;
  }

  return (
    <div>
      {status === STATUS.Paid ? (
        <IPFSDownload
          filename="emojis.zip"
          hash="QmWWH69mTL66r3H8P4wUn24t1L5pvdTJGUTKBqT11KCHS5"
          cta="Download emojis"
        />
      ) : (
        <button
          disabled={loading}
          className="buy-button"
          onClick={processTransaction}
        >
          Compre Agora üõí
        </button>
      )}
    </div>
  );
}
```

Aqui est√° a nova parte, bem direta!

```jsx
 useEffect(() => {
    // Verifique se este endere√ßo j√° comprou este item
    // Se for o caso, buscar o item e ajustar o pagamento para verdadeiro
    // Fun√ß√£o Async para evitar o bloqueio da IU
    async function checkPurchased() {
      const purchased = await hasPurchased(publicKey, itemID);
      if (purchased) {
        setStatus(STATUS.Paid);
        console.log("O endere√ßo j√° adquiriu esse item!");
      }
    }
    checkPurchased();
  }, [publicKey, itemID]);
```

### üëè Pegue os itens da API

Algo est√° me causando comich√£o h√° algum tempo. N√≥s fizemos uma codifica√ß√£o r√≠gida desde o in√≠cio para que pud√©ssemos acelerar as transa√ß√µes. Vamos consertar isso!

Primeiro, vamos criar um arquivo chamado `fetchItem.js` no diret√≥rio `pages/api`. Sim. Outro ponto de extremidade. N√£o se preocupe, √© bem pequeno!


```jsx
// Este ponto de extremidade enviar√° ao usu√°rio um hash de arquivo do IPFS
import products from "./products.json"

export default async function handler(req, res) {
  if (req.method === "POST") {
    const { itemID } = req.body;

    if (!itemID) {
      return res.status(400).send('itemID faltando');
    }

    const product = products.find((p) => p.id === itemID);


    if (product) {
      const { hash, filename } = product;
      return res.status(200).send({ hash, filename });
    } else {
      return res.status(404).send("Item n√£o encontrado");
    }
  } else {
    return res.status(405).send(`M√©todo ${req.method} n√£o permitido`);
  }
}
```


N√£o podemos usar `fetchProducts` porque estamos removendo os hashes dela. Acrescente esta parte final em `lib/api.js`:


```jsx
export const fetchItem = async (itemID) => {
  const response = await fetch("../api/fetchItem", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ itemID }),
  });
  const item = await response.json();
  return item;
}
```

E agora, podemos juntar tudo isso em `Buy.js`:

```jsx
import React, { useEffect, useState, useMemo } from "react";
import { Keypair, Transaction } from "@solana/web3.js";
import { findReference, FindReferenceError } from "@solana/pay";
import { useConnection, useWallet } from "@solana/wallet-adapter-react";
import { InfinitySpin } from "react-loader-spinner";
import IPFSDownload from "./IpfsDownload";
import { addOrder, hasPurchased, fetchItem } from "../lib/api";

const STATUS = {
  Initial: "Initial",
  Submitted: "Submitted",
  Paid: "Paid",
};

export default function Buy({ itemID }) {
  const { connection } = useConnection();
  const { publicKey, sendTransaction } = useWallet();
  const orderID = useMemo(() => Keypair.generate().publicKey, []); // Chave p√∫blica utilizada para identificar o pedido

  const [item, setItem] = useState(null); // hash IPFS & nome do arquivo do item comprado
  const [loading, setLoading] = useState(false); // Estado de carregamento de tudo acima
  const [status, setStatus] = useState(STATUS.Initial); // Status de rastreamento da transa√ß√£o

  const order = useMemo(
    () => ({
      buyer: publicKey.toString(),
      orderID: orderID.toString(),
      itemID: itemID,
    }),
    [publicKey, orderID, itemID]
  );

  // Buscar o objeto da transa√ß√£o no servidor (feito para evitar adultera√ß√µes)
  const processTransaction = async () => {
    setLoading(true);
    const txResponse = await fetch("../api/createTransaction", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(order),
    });
    const txData = await txResponse.json();

    const tx = Transaction.from(Buffer.from(txData.transaction, "base64"));
    console.log("Os dados da transa√ß√£o s√£o", tx);
    // Tentar enviar a transa√ß√£o para a rede
    try {
      const txHash = await sendTransaction(tx, connection);
      console.log(`Transa√ß√£o enviada: https://solscan.io/tx/${txHash}?cluster=devnet`);
      setStatus(STATUS.Submitted);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Verifique se este endere√ßo j√° comprou este item
    // Se for o caso, pegue o item e configure o pagamento para verdadeiro
    // Fun√ß√£o Async para evitar o bloqueio da IU
    async function checkPurchased() {
      const purchased = await hasPurchased(publicKey, itemID);
      if (purchased) {
        setStatus(STATUS.Paid);
        const item = await fetchItem(itemID);
        setItem(item);
      }
    }
    checkPurchased();
  }, [publicKey, itemID]);

  useEffect(() => {
    // Verificar se a transa√ß√£o foi confirmada
    if (status === STATUS.Submitted) {
      setLoading(true);
      const interval = setInterval(async () => {
        try {
          const result = await findReference(connection, orderID);
          console.log("Localizar a refer√™ncia da transa√ß√£o", result.confirmationStatus);
          if (result.confirmationStatus === "confirmed" || result.confirmationStatus === "finalized") {
            clearInterval(interval);
            setStatus(STATUS.Paid);
            addOrder(order);
            setLoading(false);
            alert("Obrigado por sua compra!");
          }
        } catch (e) {
          if (e instanceof FindReferenceError) {
            return null;
          }
          console.error("Erro desconhecido", e);
        } finally {
          setLoading(false);
        }
      }, 1000);
      return () => {
        clearInterval(interval);
      };
    }

    async function getItem(itemID) {
      const item = await fetchItem(itemID);
      setItem(item);
    }

    if (status === STATUS.Paid) {
      getItem(itemID);
    }
  }, [status]);

  if (!publicKey) {
    return (
      <div>
        <p>√â necess√°rio conectar sua carteira para realizar a transa√ß√£o</p>
      </div>
    );
  }

  if (loading) {
    return <InfinitySpin color="gray" />;
  }

  return (
    <div>
      {/* Exibir ou o bot√£o de compra ou o componente IPFSDownload com base na exist√™ncia de Hash */}
      {item ? (
        <IPFSDownload hash={item.hash} filename={item.filename} />
      ) : (
        <button disabled={loading} className="buy-button" onClick={processTransaction}>
          Compre agora üõí
        </button>
      )}
    </div>
  );
}
```

Muito bem feito! Sua loja agora est√° completa!

### üö® Relat√≥rio de progresso 

Por favor, fa√ßa isso, sen√£o o Yan ficar√° triste üòü

Voc√™ percorreu um longo caminho. Tenho certeza de que voc√™ aprendeu muito.

N√£o deixe de analisar o c√≥digo eu pessoalmente aprendi muita coisa te dando esse passo a passo.

Ainda n√£o acabou! Vamos implementar implementar algumas coisas ainda.

Compartilhe em `#pod-bootcamp` qual tem sido sua parte favorita deste projeto üòä 
